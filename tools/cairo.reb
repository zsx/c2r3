REBOL []

;recycle/torture
function-filter: func [
	f [object!]
][
	all [
		found? find/match f/name "cairo_"
		f/availability = clang/enum clang/CXAvailabilityKind 'CXAvailability_Available
	]
]

function-ns: func [
	f [object!]
][
	either found? find/match f/name "cairo_" [
		"cairo_"
	][
		""
	]
]

struct-filter: func [
	s [object!]
][
	false
]

enum-filter: func [
	e [object!]
][
	all [
		not empty? e/name
		not empty? e/key-value
	]
]

OUTPUT: %cairo-binding.reb

do %../lib/c2r3.reb

argv-data: compose [
	(r2utf8-string "c2r3.reb")
	(r2utf8-string "-I/usr/include/cairo")
	(r2utf8-string "-I/usr/include/glib-2.0")
	(r2utf8-string "-I/usr/lib/glib-2.0/include")
	(r2utf8-string "-I/usr/include/pixman-1")
	(r2utf8-string "-I/usr/include/freetype2")
	(r2utf8-string "-I/usr/include/libpng16")
	(r2utf8-string "-I/usr/include/harfbuzz")
	(r2utf8-string "-I/usr/include/freetype2")
	(r2utf8-string "-I/usr/include/harfbuzz")
	(r2utf8-string "-I/usr/include/libdrm")
	(r2utf8-string "-I/usr/include/libpng16")
	(r2utf8-string "-I/usr/lib/clang/3.5.0/include")
	(r2utf8-string "-fsyntax-only")
	(r2utf8-string "/usr/include/cairo/cairo.h")
]

argc: length? argv-data

argv-ptr: copy []
foreach v argv-data [append argv-ptr addr-of v]
argv: make struct! compose/deep/only [
	pointer [(argc)] data: (argv-ptr)
]

compile argc addr-of argv

write OUTPUT rejoin [{REBOL [
	Date: } to string! now/date {
	comment: "Generated by c2r3.reb, DO NOT EDIT"
]
make object! [
}]
write-output OUTPUT "cairo" %libcairo.so
write/append OUTPUT "]^/"
